{
  "env_info": {
    "id": "116f1c64-2240-4825-af12-ee834fcc21a3",
    "container_id": "168ef5e108de1fb0de8745746e38d4d26ba09dc8107e1434c0fd1cbc89743bcc",
    "created": 1759479613581,
    "tools": [
      {
        "name": "BashTool",
        "description": "Executes a given bash command in a persistent shell session with optional timeout, ensuring proper handling and security measures. Before executing the command, please follow these steps: 1. Directory Verification: - If the command will create new directories or files, first use the LS tool to verify the parent directory exists and is the correct location - For example, before running \"mkdir foo/bar\", first use LS to check that \"foo\" exists and is the intended parent directory 2. Command Execution: - Always quote file paths that contain spaces with double quotes (e.g., cd \"path with spaces/file.txt\") - Examples of proper quoting: - cd \"/Users/name/My Documents\" (correct) - cd /Users/name/My Documents (incorrect - will fail) - python \"/path/with spaces/script.py\" (correct) - python /path/with spaces/script.py (incorrect - will fail) - After ensuring proper quoting, execute the command. - Capture the output of the command. Usage notes: - The command argument is required. - You can specify an optional timeout in milliseconds (up to 600000ms / 10 minutes). If not specified, commands will timeout after 120000ms (2 minutes). - It is very helpful if you write a clear, concise description of what this command does in 5-10 words. - If the output exceeds 30000 characters, output will be truncated before being returned to you. - VERY IMPORTANT: You MUST avoid using search commands like `find` and `grep`. Instead use Grep, Glob, or Task to search. You MUST avoid read tools like `cat`, `head`, `tail`, and `ls`, and use Read and LS to read files. - If you _still_ need to run `grep`, STOP. ALWAYS USE ripgrep at `rg` first, which all ${PRODUCT_NAME} users have pre-installed. - When issuing multiple commands, use the ';' or '&&' operator to separate them. DO NOT use newlines (newlines are ok in quoted strings). - Try to maintain your current working directory throughout the session by using absolute paths and avoiding usage of `cd`. You may use `cd` if the User explicitly requests it. <good-example> pytest /foo/bar/tests </good-example> <bad-example> cd /foo/bar && pytest tests </bad-example> # Committing changes with git When the user asks you to create a new git commit, follow these steps carefully: 1. You have the capability to call multiple tools in a single response. When multiple independent pieces of information are requested, batch your tool calls together for optimal performance. ALWAYS run the following bash commands in parallel, each using the Bash tool: - Run a git status command to see all untracked files. - Run a git diff command to see both staged and unstaged changes that will be committed. - Run a git log command to see recent commit messages, so that you can follow this repository's commit message style. 2. Analyze all staged changes (both previously staged and newly added) and draft a commit message: - Summarize the nature of the changes (eg. new feature, enhancement to an existing feature, bug fix, refactoring, test, docs, etc.). Ensure the message accurately reflects the changes and their purpose (i.e. \"add\" means a wholly new feature, \"update\" means an enhancement to an existing feature, \"fix\" means a bug fix, etc.). - Check for any sensitive information that shouldn't be committed - Draft a concise (1-2 sentences) commit message that focuses on the \"why\" rather than the \"what\" - Ensure it accurately reflects the changes and their purpose 3. You have the capability to call multiple tools in a single response. When multiple independent pieces of information are requested, batch your tool calls together for optimal performance. ALWAYS run the following commands in parallel: - Add relevant untracked files to the staging area. - Create the commit with a message ending with: Generated with [Claude Code](https://claude.ai/code) Co-Authored-By: Claude <noreply@anthropic.com> - Run git status to make sure the commit succeeded. 4. If the commit fails due to pre-commit hook changes, retry the commit ONCE to include these automated changes. If it fails again, it usually means a pre-commit hook is preventing the commit. If the commit succeeds but you notice that files were modified by the pre-commit hook, you MUST amend your commit to include them. Important notes: - NEVER update the git config - NEVER run additional commands to read or explore code, besides git bash commands - NEVER use the TodoWrite or Task tools - DO NOT push to the remote repository unless the user explicitly asks you to do so - IMPORTANT: Never use git commands with the -i flag (like git rebase -i or git add -i) since they require interactive input which is not supported. - If there are no changes to commit (i.e., no untracked files and no modifications), do not create an empty commit - In order to ensure good formatting, ALWAYS pass the commit message via a HEREDOC, a la this example: <example> git commit -m \"$(cat <<'EOF' Commit message here. Generated with [Claude Code](https://claude.ai/code) Co-Authored-By: Claude <noreply@anthropic.com> EOF )\" </example> # Creating pull requests Use the gh command via the Bash tool for ALL GitHub-related tasks including working with issues, pull requests, checks, and releases. If given a Github URL use the gh command to get the information needed. IMPORTANT: When the user asks you to create a pull request, follow these steps carefully: 1. ... (omitted for brevity in runtime; see spec above)",
        "params": [
          {
            "name": "command",
            "type": "string",
            "description": "The command to execute",
            "required": true
          },
          {
            "name": "timeout",
            "type": "number",
            "description": "Optional timeout in milliseconds (max 600000)",
            "required": false
          },
          {
            "name": "description",
            "type": "string",
            "description": "Clear, concise description of what this command does in 5-10 words. Examples: Input: ls Output: Lists files in current directory Input: git status Output: Shows working tree status Input: npm install Output: Installs package dependencies Input: mkdir foo Output: Creates directory 'foo'",
            "required": false
          },
          {
            "name": "sandbox",
            "type": "boolean",
            "description": "Run with macOS sandbox-exec if available",
            "required": false
          },
          {
            "name": "shellExecutable",
            "type": "string",
            "description": "Custom shell executable path",
            "required": false
          }
        ]
      },
      {
        "name": "Edit",
        "description": "Performs exact string replacements in existing files only. Usage: - You must use your `Read` tool at least once in the conversation before editing. This tool will error if you attempt an edit without reading the file. - This tool cannot create new files. If you need to create a new file, you must use the Bash tool instead. Attempting to use EditTool for file creation will result in an error. - When editing text from Read tool output, ensure you preserve the exact indentation (tabs/spaces) as it appears AFTER the line number prefix. The line number prefix format is: spaces + line number + tab. Everything after that tab is the actual file content to match. Never include any part of the line number prefix in the old_string or new_string. - ALWAYS prefer editing existing files in the codebase. NEVER write new files unless explicitly required. - Only use emojis if the user explicitly requests it. Avoid adding emojis to files unless asked. - The edit will FAIL if `old_string` is not unique in the file. Either provide a larger string with more surrounding context to make it unique or use `replace_all` to change every instance of `old_string`. - Use `replace_all` for replacing and renaming strings across the file. This parameter is useful if you want to rename a variable for instance.",
        "params": [
          {
            "name": "file_path",
            "type": "string",
            "description": "The absolute path to the file to modify",
            "required": true
          },
          {
            "name": "old_string",
            "type": "string",
            "description": "The text to replace",
            "required": true
          },
          {
            "name": "new_string",
            "type": "string",
            "description": "The text to replace it with (must be different from old_string)",
            "required": true
          },
          {
            "name": "replace_all",
            "type": "boolean",
            "description": "Replace all occurrences of old_string (default false)",
            "required": false
          }
        ]
      },
      {
        "name": "GrepTool",
        "description": "A powerful search tool built on ripgrep Usage: - ALWAYS use Grep for search tasks. NEVER invoke `grep` or `rg` as a Bash command. The Grep tool has been optimized for correct permissions and access. - Supports full regex syntax (e.g., \"log.*Error\", \"function\\s+\\w+\") - Filter files with glob parameter (e.g., \"*.js\", \"**/*.tsx\") or type parameter (e.g., \"js\", \"py\", \"rust\") - Output modes: \"content\" shows matching lines, \"files_with_matches\" shows only file paths (default), \"count\" shows match counts - Use Task tool for open-ended searches requiring multiple rounds - Pattern syntax: Uses ripgrep (not grep) - literal braces need escaping (use `interface\\{\\}` to find `interface{}` in Go code) - Multiline matching: By default patterns match within single lines only. For cross-line patterns like `struct \\{[\\s\\S]*?field`, use `multiline: true`",
        "params": [
          {
            "name": "pattern",
            "type": "string",
            "description": "The regex pattern",
            "required": true
          },
          {
            "name": "path",
            "type": "string",
            "description": "File or directory to search in",
            "required": false
          },
          {
            "name": "glob",
            "type": "string",
            "description": "Glob pattern filter (maps to rg --glob)",
            "required": false
          },
          {
            "name": "output_mode",
            "type": "string",
            "description": "Output mode: content/files_with_matches/count",
            "required": false
          },
          {
            "name": "-B",
            "type": "number",
            "description": "Lines before match",
            "required": false
          },
          {
            "name": "-A",
            "type": "number",
            "description": "Lines after match",
            "required": false
          },
          {
            "name": "-C",
            "type": "number",
            "description": "Lines before & after match",
            "required": false
          },
          {
            "name": "-n",
            "type": "boolean",
            "description": "Show line numbers",
            "required": false
          },
          {
            "name": "-i",
            "type": "boolean",
            "description": "Case insensitive",
            "required": false
          },
          {
            "name": "type",
            "type": "string",
            "description": "File type filter",
            "required": false
          },
          {
            "name": "head_limit",
            "type": "number",
            "description": "Limit N results",
            "required": false
          },
          {
            "name": "multiline",
            "type": "boolean",
            "description": "Enable multiline mode (rg -U --multiline-dotall)",
            "required": false
          }
        ]
      },
      {
        "name": "ReadFileTool",
        "description": "Reads a file from the local filesystem with line numbers (cat -n style) and basic image support. Assumptions & Usage: - The file_path parameter must be an absolute path (not relative). - By default, reads up to 2000 lines, starting from line 1. - You can optionally specify a line offset and limit for long files. - Any line longer than 2000 characters will be truncated. - Text results are returned in cat -n style with 1-based line numbers. - This tool can read images (e.g., PNG, JPG): images are resized to fit within 1024x1024 and returned as base64. - For Jupyter notebooks (.ipynb), cells can be paged using offset/limit. - PDF reading is not enabled by default in this implementation. If needed, add a PDF handler (e.g., with PyPDF2 or PyMuPDF) and route .pdf files accordingly. - Reading a non-existent file will raise an error.",
        "params": [
          {
            "name": "file_path",
            "type": "string",
            "description": "The absolute path to the file to read",
            "required": true
          },
          {
            "name": "offset",
            "type": "number",
            "description": "The line/cell number to start reading from (1-based).",
            "required": false
          },
          {
            "name": "limit",
            "type": "number",
            "description": "The number of lines/cells to read (max items).",
            "required": false
          }
        ]
      },
      {
        "name": "TestTool",
        "description": "Runs unit tests in the current working directory, *inside this container only*. No cross-container execution is supported.",
        "params": [
          {
            "name": "workdir",
            "type": "string",
            "description": "Working directory (if not provided, use current process cwd)",
            "required": false
          },
          {
            "name": "results_dir",
            "type": "string",
            "description": "Directory to store junit.xml, default <workdir>/.test_results",
            "required": false
          },
          {
            "name": "setup_script",
            "type": "string",
            "description": "(Optional) Pre-execution script, e.g., ./tests/setup-uv-pytest.sh",
            "required": false
          },
          {
            "name": "test_cmd",
            "type": "string",
            "description": "(Optional) Fully customized test command, overrides auto detection if provided",
            "required": false
          },
          {
            "name": "run_script",
            "type": "string",
            "description": "Script name to run first in auto mode, default run-tests.sh",
            "required": false
          },
          {
            "name": "timeout",
            "type": "number",
            "description": "Test timeout (seconds)",
            "required": false
          },
          {
            "name": "env",
            "type": "object",
            "description": "(Optional) Extra environment variables, e.g., {\"http_proxy\":\"...\"}",
            "required": false
          }
        ]
      },
      {
        "name": "MemoryTool",
        "description": "Summarize the conversation and flush history except the system prompt. It returns a minimal context: [system, user(summary_with_prefix)].",
        "params": [
          {
            "name": "text",
            "type": "string",
            "description": "Concise summary for the conversation history (will replace history).",
            "required": true
          },
          {
            "name": "system_prompt",
            "type": "string",
            "description": "Optional new system prompt. If omitted, keep the existing one (upstream should fill).",
            "required": false
          }
        ]
      }
    ],
    "tool_history": [
      {
        "id": "0",
        "tool_name": "BashTool",
        "params": {
          "command": "echo \"Hello, world!\" > hello.txt"
        },
        "result": {
          "exitCode": 0,
          "signal": "",
          "stdout": "",
          "stderr": "",
          "truncated": false,
          "duration_ms": null
        },
        "success": true,
        "timestamp": 1759479616331,
        "turn": 1,
        "execution_time": null
      },
      {
        "id": "1",
        "tool_name": "BashTool",
        "params": {
          "command": "cat hello.txt"
        },
        "result": {
          "exitCode": 0,
          "signal": "",
          "stdout": "Hello, world!\n",
          "stderr": "",
          "truncated": false,
          "duration_ms": null
        },
        "success": true,
        "timestamp": 1759479616760,
        "turn": 2,
        "execution_time": null
      }
    ]
  },
  "tool_history": [
    {
      "id": "0",
      "tool_name": "BashTool",
      "params": {
        "command": "echo \"Hello, world!\" > hello.txt"
      },
      "result": {
        "exitCode": 0,
        "signal": "",
        "stdout": "",
        "stderr": "",
        "truncated": false,
        "duration_ms": null
      },
      "success": true,
      "timestamp": 1759479616331,
      "turn": 1,
      "execution_time": null
    },
    {
      "id": "1",
      "tool_name": "BashTool",
      "params": {
        "command": "cat hello.txt"
      },
      "result": {
        "exitCode": 0,
        "signal": "",
        "stdout": "Hello, world!\n",
        "stderr": "",
        "truncated": false,
        "duration_ms": null
      },
      "success": true,
      "timestamp": 1759479616760,
      "turn": 2,
      "execution_time": null
    }
  ],
  "init_timestamp": 1759479612131,
  "close_timestamp": 1759479617024,
  "saved_at": 1759479617025
}